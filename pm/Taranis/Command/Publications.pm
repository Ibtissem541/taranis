# This file is part of Taranis, Copyright NCSC-NL.  See http://taranis.ncsc.nl
# Licensed under EUPL v1.2 or newer, https://spdx.org/licenses/EUPL-1.2.html

package Taranis::Command::Publications;

use warnings;
use strict;

use Carp           qw(confess);
use List::Util     qw(first);
use POSIX          qw(strftime);
use HTML::Entities qw(decode_entities);

use Taranis        qw(:all);
use Taranis::Log   ();
use Taranis::Config;
use Taranis::Database qw(withTransaction);
use Taranis::FunctionalWrapper qw(
	Config Database Publication PublicationEndOfShift Publish
	ReportContactLog ReportIncidentLog ReportSpecialInterest ReportToDo
	Template Users
);
use Taranis::Publication;
use Taranis::Publication::EndOfShift;
use Taranis::Publish;
use Taranis::Report::ContactLog;
use Taranis::Report::IncidentLog;
use Taranis::Report::SpecialInterest;
use Taranis::Report::ToDo;
use Taranis::Template;
use Taranis::Users;

my %handlers = (
	'autosend-eos'      => \&publications_autosend_eos,
);

Taranis::Commands->plugin(publications => {
	handler       => \&publications_control,
	requires_root => 0,
	sub_commands  => [ keys %handlers ],
	getopt        => [
		'log|l'
	],
	help          => <<'__HELP',
SUB-COMMANDS:
  autosend-eos [-l]       send EOS if forgotten

OPTIONS:
  -l --log FILENAME       alternative logging (maybe '-' for stdout)
__HELP
} );

sub publications_control(%) {
	my %args = @_;

	my $subcmd = $args{sub_command}
		or confess;

	my $handler = $handlers{$subcmd}
		or confess $subcmd;

	$handler->(\%args);
}

# was half of backend_tools/report.pl

sub publications_autosend_eos($) {
	my $args = shift;

	#XXX shouldn't we just configure this in cron.cycle?
	Config->{auto_send_eos} =~ 'yes'
		or return;

	my $logger          = Taranis::Log->new('check-eos-sent', $args->{log});
	my $db              = Database->simple;

	my $eos_status_info = PublicationEndOfShift->getEndOfShiftSendingStatus;
	my $previous_status = $eos_status_info->{previous}{status};
	if(lc $previous_status ne 'red') {
		$logger->info("EOS OK, nothing to do.");
		return;
	}

	my $eos_shifts  = PublicationEndOfShift->sortShifts;
	my $delayed_eos = first { $_->{isPreviousShift} } @$eos_shifts;
	$delayed_eos  ||= $eos_shifts->[-1];

	my $eos_user    = Config->{publish_eos_user};
	unless($db->query('SELECT 1 FROM users WHERE username = ?', $eos_user)->list) {
		$logger->error("publish_eos_user '$eos_user' not found for EOS.");
		exit 1;
	}

	my $timeframe_begin = strftime '%Y%m%d %H%M', localtime($delayed_eos->{startTime});
	my $timeframe_end   = strftime '%Y%m%d %H%M', localtime($delayed_eos->{endTime});

	# contact log
	my $contactLogs  = ReportContactLog->getContactLog( created =>
		{ '>' => $timeframe_begin, '<' => $timeframe_end } );

	my $contact_log  = Template->processTemplate('write_eos_contact_log.tt',
		{ contactLogEntries => $contactLogs }, 1 );

	# incident log
	my $incidentLogs = ReportIncidentLog->getIncidentLog( 'ril.status' => [1,2] );
	my $incident_log = Template->processTemplate('write_eos_incident_log.tt',
		{ incidentLogEntries => $incidentLogs }, 1 );

	# to-do
	my $todos        = ReportToDo->getToDo( done_status => {'!=' => 100} );
	my $todo         = Template->processTemplate( 'write_eos_todo.tt',
		{ todos => $todos }, 1 );

	# special interests
	my $specialInterests = ReportSpecialInterest->getSpecialInterest(
		date_start => { '>' => $timeframe_begin },
		date_end   => { '<' => $timeframe_begin }
	);
	my $special_interest = Template->processTemplate( 'write_eos_special_interest.tt',
		{ specialInterests => $specialInterests }, 1 );

	# done
	Users->getUserActions( 
		startDate => $timeframe_begin,
		endDate   => $timeframe_end,
		action    => [ { -like => 'delete report%' }, 'edit to-do done', 'edit incident log status' ]
	);

	my @userActions;
	while ( Users->nextObject() ) {
		push @userActions, Users->getObject();
	}

	my %vars     = (actions => \@userActions);
	my $eos_done = Template->processTemplate('write_eos_done.tt', \%vars, 1);
	my $eosTypeId = Publication->getPublicationTypeId(eos => 'email');

	# only add expired items in the first shift of the day

	my $already_done = $db->query(<<'__FIND_TODAY', $eosTypeId)->list;
 SELECT 1
   FROM publication
  WHERE type   = ?
    AND status = 3
    AND published_on > CURRENT_DATE
__FIND_TODAY

	unless($already_done) {
		my $specialInterests = ReportSpecialInterest->getSpecialInterest(date_end => {
			'<' => \'NOW()',
			'=' => \"(current_date - '1 second'::interval )"
		} );
		$eos_done .= Template->processTemplate( 'write_eos_special_interest.tt',
			{ specialInterests => $specialInterests }, 1 );
	}

	my $notes = 'This End-of-Shift was generated by Taranis automagically...';

	# create a new EoS

	my ($publicationId, $eosId);
	withTransaction {

		Publication->addPublication(
			title        => 'End-of-Shift by Taranis [automagically]',
			type         => $eosTypeId,
			status       => 3,
			created_by   => $eos_user,
			published_by => $eos_user,
			published_on => nowstring(10),
		);
		$publicationId = Publication->{dbh}->getLastInsertedId('publication');

		Publication->linkToPublication(
			table            => 'publication_endofshift',
			handler          => $eos_user,
			timeframe_begin  => $timeframe_begin,
			timeframe_end    => $timeframe_end,
			notes            => $notes,
			todo             => $todo,
			contact_log      => $contact_log,
			incident_log     => $incident_log,
			special_interest => $special_interest,
			done             => $eos_done,
			publication_id   => $publicationId,
		);
		$eosId = Publication->{dbh}->getLastInsertedId('publication_endofshift');
	};

	my $previewText = Template->processPreviewTemplate('eos', 'email',
		$eosId, $publicationId, 0);

	Publication->setPublication(
		id       => $publicationId,
		contents => $previewText,
	);

	# send EoS
	my ($from, $until) = map strftime('%A %d-%m-%Y %H:%M', localtime($_)),
		$delayed_eos->{startTime}, $delayed_eos->{endTime};

	my $response = Publish->sendPublication(
		subject    => "[AUTO-GENERATED MESSAGE] End-of-Shift - $from - $until",
		msg        => decode_entities($previewText),
		attach_xml => 0,
		pub_type   => 'eos',
		from_name  => 'Taranis'
	);

	if($response ne 'OK') {
		$logger->error("trying to send EOS, got response: $response");
		Publication->setPublication(
			id           => $publicationId,
			contents     => $previewText,
			status       => 2,
			published_on => undef
		);

		exit 1;
	}

	$logger->info("End-of-Shift sent successfully");
}

1;
